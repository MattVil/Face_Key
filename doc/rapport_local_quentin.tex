% !TEX encoding = IsoLatin9
\documentclass[conference]{IEEEtran}

\usepackage[francais]{babel}
\usepackage[latin1]{inputenc}
\usepackage[cyr]{aeguill}
\usepackage[T1]{fontenc}

\usepackage{ifpdf}
\usepackage{cite}
\usepackage[pdftex]{graphicx}
\usepackage{epsfig}

\graphicspath{{./data/}}

\DeclareGraphicsExtensions{.pdf,.jpeg,.png,.pdf}

\usepackage[cmex10]{amsmath}
\usepackage{empheq}
\usepackage[tight,footnotesize]{subfigure}
\usepackage[caption=false,font=footnotesize]{subfig}
\hyphenation{}

\usepackage{listings}
\usepackage{color}


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
  frame =tBlR,
  rulesep =1mm ,
  framesep =5mm,
  framerule =2pt,
  xrightmargin =5mm,
  xleftmargin =5mm ,
}


\begin{document}
\onecolumn

\title{Face Key}

\author{\IEEEauthorblockN{Quentin GERARD, Louis L'HARIDON et Matthieu VILAIN}
\IEEEauthorblockA{CMI Systèmes Intelligents et Communicants, Université de Cergy-Pontoise\\
mail@etu.u-cergy.fr}}

\maketitle


\begin{abstract}
\boldmath abstract of the project
\end{abstract}

\section{Sécurité}
\subsection{Introduction au problème}
Lors de l'utilisation de l'application, beaucoup de données transitent entre les différents blocs que composent l'architecture du logiciel, et/ou sont stockés dans le Base de Donnée. Parmis elles, se trouvent des informations extrêmement sensibles concernant les utilisateurs. Pour un utilisateur, nous pouvons y trouver ces informations (liste non ordonnée et non exhaustive):
\begin{itemize}
\item Adresses mails
\item Mot de passe (de l'application Face Key)
\item Combinaisons Identifiants/Mot de passe de plusieurs sites
\item Coordonnées Bancaires
\item Et d'autres
\end{itemize}

Si un utilisateur mal intentionné arriverait à intercepter les messages entre le client et le serveur, en se plaçant entre les deux grâce à un attaque basique de type Man in the Middle (MITM), alors il aurait accès à toutes ces données. De même si la base de donnée arrivait un jour à être compromise, et accessible par un utilisateur mal intentionné, alors il aurait également accès à toutes les données.
Il nous faut donc trouver une solution qui nous permet à la fois de sécuriser les envoie de données Client/Server, et une solution qui nous permet de rendre illisible les informations dans la base de données à tous les utilisateurs autres que l'utilisateur concerné.

\subsection{RSA}
\subsubsection{Introduction}
Le RSA est un algorithme de cryptographie dit "asymétrique" (une clé privé et une clé publique, contrairement à la cryptographie symétrique qui utilise la même clé pour crypter et décrypter). Il a été rendu public par R.L. Rivest, A. Shamir, et L. Adleman dans un papier publié en 1977 appelé "\textit{A Method for Obtaining Digital Signatures and Public-Key Cryptosystems}". Il a pour but, à la fois de crypter des messages afin qu'ils puissent être transmis sans risquer d'être lu par une personne tierce, mais aussi de signer les messages. Un des principe du RSA est que la clé privé, permettant de décrypter les messages soit impossible à retrouver à partir de la clé publique, qui elle permet d'encrypter les messages.
Nous avons donc décidé d'utiliser cette méthode afin de crypter les messages entre le Client et le Server.
\newline{}
\subsubsection{Génération des clés}
La génération des clés appartient au receveur des messages, il doit ensuite communiquer la clé publique, qui n'est pas une information sensible, à l'envoyeur du message. Dans notre cas, le serveur et le client vont chacun générer de leur coté une pair de clés et transmettre à l'autre partie, la clé publique. Ainsi, même si les clés sont interceptés, n'importe qui pourra envoyer des messages au client et au serveur, mais personnes ne pourra lire les messages crypter envoyé, à l'exception du client et du serveur.

Pour créer les clés nous devons d'abord choisir deux nombres premiers $p$ et $q$ et ensuite calculer \[n = p.q\]Notons que $n$ sera présent dans la clé publique il est donc important de trouver deux nombres premiers $p$ et $q$ assez grand pour qu'il soit difficile de décomposer $n$ (Il est recommandé d'après les auteurs d'utiliser un nombre premiers composer de 100 chiffres), en effet chaque nombre $n$ à une décomposition \textbf{unique} en facteur premiers. On cherche ensuite $d$ tel que: \[pgcd(d, (p - 1).(q - 1)) = 1\]
Nous venons donc de créer notre clé privé \((d, n)\), pour trouver notre clé publique nous devons calculer $e$ tel que: \[e . d \equiv (mod  (p - 1) . (q - 1)) \]
Notre clé publique est donc le couple \((e, n)\).
\newline{}
\subsubsection{Cryptage et Décryptage des messages}
Pour crypter un message $M$ nous avons besoin de notre clé publique \((e, n)\), notre message crypter $C$ se calcule de la manière suivante: \[C \equiv M^e (mod \phantom{s}n)\]
La fonction de décryptage est tout aussi simple, à partir de notre message crypter $C$ , et de notre clé privé \((d, n)\), nous calculons: \[M \equiv C^d (mod \phantom{s}n)\]
La méthode décrite içi est démontrée mathématiquement dans le papier d'origine de R.L. Rivest, A. Shamir, et L. Adleman.

\bibliographystyle{IEEEtran}

\end{document}
